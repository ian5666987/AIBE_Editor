using Aibe.Models.DB;
using Extension.Models;
using System;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Drawing;
using System.Linq;
using System.Reflection;
using System.Text;
using logic = Aibe.Models.Tests.AibeSyntaxCheckerLogic;

namespace Aibe.Models.Docs {
  public class AibeDocument : BaseInfo {
    public string TableName { get { return string.IsNullOrWhiteSpace(WrittenTableName) ? GivenTableName : WrittenTableName; } }
    public string WrittenTableName { get {
        if (!Paragraphs.Any())
          return null;
        AibeParagraph para = Paragraphs.FirstOrDefault(x => x.IsNewTableParagraph);
        if (para == null)
          return null;
        return para.TableName;
      } }
    public string GivenTableName { get; private set; }
    public int Length { get; private set; }
    public bool IsMinimized { get; private set; }
    public List<AibeParagraph> Paragraphs { get; private set; } = new List<AibeParagraph>();
    public List<AibeSection> NonMeaningfulSections { get; private set; } = new List<AibeSection>();
    public List<AibeSection> Sections { get; private set; } = new List<AibeSection>();

    //To make it very simple, every start of the section, should be started with ///---
    public const string TableHeader = "TABLE:";
    public const string StartString = "///---";

    public static Dictionary<SectionType, Color> SectionColors = new Dictionary<SectionType, Color> {
      { SectionType.AggregateName, Color.Teal },
      { SectionType.Appendix, Color.DarkGray },
      { SectionType.AutoGenerated, Color.DarkGreen },
      { SectionType.Cid, Color.DarkGreen },
      { SectionType.Color, Color.Green },
      { SectionType.ColoringComparisonCode, Color.Gray },
      { SectionType.ColumnName, Color.DarkBlue },
      { SectionType.DataStoredProcedure, Color.DarkRed },
      { SectionType.DataStoredProcedureParameter, Color.DarkBlue },
      { SectionType.DateTimeFormat, Color.DarkRed },
      { SectionType.FileFormat, Color.DarkRed },
      { SectionType.GroupByAutoDirective, Color.DarkGreen },
      { SectionType.HistoryColumnName, Color.DarkBlue },
      { SectionType.Keyword, Color.DarkGreen },
      { SectionType.ListType, Color.Green },
      { SectionType.MetaItemColumnName, Color.DarkViolet },
      { SectionType.MinMax, Color.DarkGreen },
      { SectionType.NewParagraph, Color.DarkGray },
      { SectionType.NewTableName, Color.SteelBlue },
      { SectionType.NewTableNamePrefix, Color.DarkViolet },
      { SectionType.Now, Color.DarkGreen },
      { SectionType.Number, Color.Brown },
      { SectionType.OrderByDirective, Color.DarkRed },
      { SectionType.Page, Color.Teal },
      { SectionType.Parameter, Color.DarkGreen },
      { SectionType.Regex, Color.DarkRed },
      { SectionType.Role, Color.DarkGreen },
      { SectionType.RowAction, Color.Teal },
      { SectionType.ScRefColumnName, Color.DarkBlue },
      { SectionType.ScriptConstructorAttribute, Color.SteelBlue },
      { SectionType.Self, Color.DarkGreen },
      { SectionType.Skip, Color.DarkGreen },
      { SectionType.StaticValue, Color.DarkRed },
      { SectionType.SQLAggregationScript, Color.DarkRed },
      { SectionType.SQLScriptPrefix, Color.Blue },
      { SectionType.SQLScript, Color.DarkRed },
      { SectionType.TableAction, Color.Teal },
      { SectionType.TableName, Color.Teal },
      { SectionType.TableSource, Color.Teal },
      { SectionType.TableType, Color.Teal },
      { SectionType.Tag, Color.Gray },
      { SectionType.TemplateName, Color.Brown },
      { SectionType.Text, Color.DarkRed },
      { SectionType.ThisTableColumnName, Color.Blue },
      { SectionType.TriggerName, Color.Blue },
      { SectionType.TriggerRowAction, Color.Teal },
      { SectionType.TrueFalse, Color.DarkGreen },
      { SectionType.Unknown, Color.Red },
      { SectionType.UserColumnName, Color.Blue },
      { SectionType.UserDBReferencePrefix, Color.Teal },
      { SectionType.UserRelatedDirective, Color.DarkRed },
      { SectionType.UserStoredProcedure, Color.DarkRed },
      { SectionType.UserStoredProcedureParameter, Color.DarkBlue },
      { SectionType.Value, Color.Brown },
    };

    public AibeDocument(string desc, string tableName) : base(desc) {
      Init(desc, tableName);
    }

    public void Init(BaseMetaItem item) {
      PropertyInfo[] props = typeof(BaseMetaItem).GetProperties();
      StringBuilder sb = new StringBuilder();
      foreach(var prop in props) {
        if (prop.Name.Equals(Aibe.DH.Cid)) //Cid done
          continue;
        object val = prop.GetValue(item, null);
        string valStr = val == null ? string.Empty : val.ToString();
        if (string.IsNullOrWhiteSpace(valStr))
          continue;
        string parStr = string.Concat(StartString, prop.Name.Equals(Aibe.DH.MetaTableNameColumnName) ?
          TableHeader : prop.Name, " ", valStr, "\n");
        sb.Append(parStr);
      }
      string desc = sb.ToString();
      UntrimmedOriginalDesc = desc;
      OriginalDesc = desc?.Trim();
      Init(desc, null); //everything must be in the BaseMetaItem
    }

    public void Init(string desc, string tableName) {
      if (string.IsNullOrWhiteSpace(desc))
        return;
      IsValid = true;
      Length = desc.Length;
      GivenTableName = tableName; //this can be null

      List<string> paraDescs = desc.Split(new string[] { StartString }, StringSplitOptions.None).ToList();
      int index = 0;
      bool firstTime = true;
      foreach (var paraDesc in paraDescs) {
        if (string.IsNullOrWhiteSpace(paraDesc)) {
          if (!firstTime) {
            AibeSection section = new AibeSection(StartString, index, 0, null, SectionType.NewParagraph);
            NonMeaningfulSections.Add(section);
            index += StartString.Length;
          }
          if (paraDesc.Length > 0) {
            AibeSection section = new AibeSection(paraDesc, index, 0, null, SectionType.Empty);
            NonMeaningfulSections.Add(section);
            index += paraDesc.Length;
          }
          firstTime = false;
          continue;
        }
        AibeParagraph para = new AibeParagraph(StartString + paraDesc, index, this);
        Paragraphs.Add(para);
        index += para.Length;

        Sections.AddRange(para.Sections);
        firstTime = false;
      }

      Sections.AddRange(NonMeaningfulSections);
      Sections = Sections.OrderBy(x => x.StartIndex).ToList();
    }

    public void Minimize() {
      int index = 0;
      NonMeaningfulSections.Clear();
      Sections.Clear();
      StringBuilder sb = new StringBuilder();
      List<AibeParagraph> newParas = new List<AibeParagraph>();
      foreach(var para in Paragraphs) {
        para.Minimize(index);
        newParas.Add(para);
        index += para.Length;
        Sections.AddRange(para.Sections);
        sb.Append(para.UntrimmedOriginalDesc);
      }
      UntrimmedOriginalDesc = sb.ToString();
      OriginalDesc = UntrimmedOriginalDesc.Trim();
      Paragraphs = newParas;
      Length = Paragraphs.Sum(x => x.Length);
      IsMinimized = true;
    }

    public BaseMetaItem CreateBaseMeta() {
      BaseMetaItem item = new BaseMetaItem();
      AibeDocument usedDoc = null;
      if (IsMinimized)
        usedDoc = this;
      else {
        usedDoc = new AibeDocument(UntrimmedOriginalDesc, TableName);
        usedDoc.Minimize();
      }
      PropertyInfo[] props = typeof(BaseMetaItem).GetProperties();
      PropertyInfo tnProp = typeof(BaseMetaItem).GetProperty(Aibe.DH.MetaTableNameColumnName); //special table name property
      tnProp.SetValue(item, usedDoc.TableName, null);
      foreach (var prop in props) {
        AibeParagraph para = usedDoc.Paragraphs.FirstOrDefault(x => x.IsValid && !x.IsNewTableParagraph &&
          x.ColumnName.Equals(prop.Name));
        if (para == null || prop.Name == Aibe.DH.Cid)
          continue;
        object val = para.Value;
        prop.SetValue(item, val, null);
      }
      return item;
    }

    public BaseScriptModel ToSQLScript(bool isNew) {
      string tableName = TableName;
      if (string.IsNullOrWhiteSpace(tableName))
        return null;
      AibeDocument minDoc = new AibeDocument(UntrimmedOriginalDesc, GivenTableName);
      minDoc.Minimize();
      StringBuilder sb = new StringBuilder();
      StringBuilder backSb = new StringBuilder();
      sb.Append(isNew ? "INSERT INTO [" + Aibe.DH.MetaTableName + "] ([" + Aibe.DH.MetaTableNameColumnName + "], " : 
        "UPDATE [" + Aibe.DH.MetaTableName + "]");
      backSb.Append(isNew ? " VALUES (@par0, " : " SET ");
      List<SqlParameter> pars = new List<SqlParameter>();
      pars.Add(new SqlParameter("@par0", tableName));
      int index = 1; //starts from 1, because 0 is reserved for table name
      foreach (var para in minDoc.Paragraphs) {
        string parName = "@par" + index;
        if (!para.IsValid || para.IsNewTableParagraph) //do not process new table paragraph or columnless item
          continue;
        if (index > 1) {
          sb.Append(isNew ? ", " : string.Empty);
          backSb.Append(", ");
        }
        sb.Append(isNew ? "[" + para.ColumnName + "]" : string.Empty);
        backSb.Append(isNew ? parName : "[" + para.ColumnName + "]=" + parName);        
        pars.Add(new SqlParameter(parName, para.DbValue)); //mostly are string, except for ItemsPerPage, DisableFilter. Handled internally.
        index++;
      }
      sb.Append(isNew ? ")" : string.Empty);
      backSb.Append(isNew ? ")" : " WHERE [" + Aibe.DH.MetaTableNameColumnName + "]=@par0");
      string script = string.Concat(sb.ToString(), backSb.ToString());
      BaseScriptModel scriptModel = new BaseScriptModel(script, pars);
      return scriptModel;
    }

    public static Dictionary<string, string> TypicalTemplateTexts = new Dictionary<string, string> {
      { Aibe.DH.MICNTableName, "MyTableName" },
      { Aibe.DH.MICNDisplayName, "Table Display Name" },
      { Aibe.DH.MICNItemsPerPage, "15" },
      { Aibe.DH.MICNOrderBy, Aibe.DH.Cid },
      { Aibe.DH.MICNActionList, string.Concat(Aibe.DH.CreateActionName, ";", 
        Aibe.DH.EditActionName, ";", Aibe.DH.DeleteActionName, ";", Aibe.DH.DetailsActionName) },
      { Aibe.DH.MICNDefaultActionList, string.Concat(Aibe.DH.CreateActionName, ";",
        Aibe.DH.EditActionName, ";", Aibe.DH.DeleteActionName, ";", Aibe.DH.DetailsActionName) },
      { Aibe.DH.MICNColumnExclusionList, Aibe.DH.Cid },
      { Aibe.DH.MICNDetailsExclusionList, Aibe.DH.Cid },
      { Aibe.DH.MICNAccessExclusionList, Aibe.DH.AnonymousRole },
    };

    public static string CreateTemplateText(bool isNew, bool isTypical) {
      StringBuilder sb = new StringBuilder();
      PropertyInfo[] props = typeof(BaseMetaItem).GetProperties();
      List<string> propNames = props.Select(x => x.Name).ToList();
      if (isNew) {
        sb.Append(StartString);
        sb.Append(TableHeader);
        sb.Append(" " + (isTypical ? TypicalTemplateTexts[Aibe.DH.MICNTableName] : string.Empty) + "\n");
      }
      foreach (var column in logic.MetaItemColumnNames) {
        if (!propNames.Any(x => column.Equals(x))) //do not process if nothing is matched by the property
          continue;
        sb.Append(StartString);
        sb.Append(column);
        sb.Append(" ");
        if (isTypical && TypicalTemplateTexts.ContainsKey(column))
          sb.Append(TypicalTemplateTexts[column]);
        sb.Append("\n");
      }
      return sb.ToString();
    }
  }

  public enum SectionType {
    Unassigned, //initial value
    //----------
    TableName,
    ColumnName,
    ThisTableColumnName, //to distinguish from normal column name
    UserColumnName,
    ScRefColumnName, //only to provide column name for ScriptConstructorColumns
    HistoryColumnName, //may nor really be able to checked, but leave it be, who knows
    MetaItemColumnName,
    RowAction,
    TriggerRowAction, //Only consists of create, edit, delete
    TableAction,
    Role,
    Page, //used for CustomDateTimeFormatColumns
    OrderByDirective,
    UserRelatedDirective,
    Keyword, //SKIP, AUTO-GENERATED, SQL-SCRIPT etc...
    Tag, //<reg> and <ex>
    ColoringComparisonCode,
    AggregateName,
    Color,
    ScriptConstructorAttribute,
    TrueFalse,
    TemplateName, //very special in email makers
    TableType, //not yet implemented but reserved
    TableSource, //the only possible table sources
    Skip, //only return skip keyword
    Self, //only return self keyword
    Now, //only return now keyword
    Cid, //only return cid keyword
    AutoGenerated, //only return auto-generated keyword
    UserDBReferencePrefix, //only return USER:
    SQLScriptPrefix, //only return SQL-SCRIPT:
    NewTableNamePrefix, //for the very beginning, only return TABLE:
    MinMax, //for number limit only
    GroupByAutoDirective, //for later use
    NewParagraph, //Symbol ///---
    //--------below are having no suggestion
    TriggerName, //pretty hard to be implemented, leave it for now... it is implemented still, to indicate the position without suggestions
    SQLScript, //only for coloring
    DataStoredProcedure, //only for coloring
    UserStoredProcedure, //only for coloring
    DataStoredProcedureParameter, //only for coloring
    UserStoredProcedureParameter, //only for coloring
    SQLAggregationScript, //only for coloring
    Symbol, //such as ; or = or | or :
    Text, //only for text such as in the Display Name
    ListType, //only for ListType
    Value, //Generic value, can be parameter or static
    Number, //for row size and picture dimension
    Parameter, //Such as @@Data.User
    StaticValue, //for TableValueReference static item
    FileFormat, //for NonPictureAttachmentColumns only
    Regex, //for regex script
    DateTimeFormat, //for date time format
    NewTableName, //for the very beginning
    Empty, //just collection of empty string
    Appendix, //really just undescribed final section
    Other, //cannot show the choice
    Unknown, //for automatic error
  };
}
