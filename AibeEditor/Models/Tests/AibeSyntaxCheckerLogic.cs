using Aibe.Models.DB;
using Aibe.Models.Docs;
using Extension.Database.SqlServer;
using Extension.Models;
using Extension.String;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.SqlClient;
using System.Drawing;
using System.Linq;
using System.Reflection;

namespace Aibe.Models.Tests {
  public class AibeSyntaxCheckerLogic {
    public static readonly List<string> MetaItemColumnNames = new List<string>() {
      Aibe.DH.MICNDisplayName,
      Aibe.DH.MICNTableSource,
      Aibe.DH.MICNPrefilledColumns,
      Aibe.DH.MICNItemsPerPage,
      Aibe.DH.MICNOrderBy,
      Aibe.DH.MICNActionList,
      Aibe.DH.MICNDefaultActionList,
      Aibe.DH.MICNTableActionList,
      Aibe.DH.MICNDefaultTableActionList,
      Aibe.DH.MICNTextFieldColumns,
      Aibe.DH.MICNPictureColumns,
      Aibe.DH.MICNIndexShownPictureColumns,
      Aibe.DH.MICNRequiredColumns,
      Aibe.DH.MICNNumberLimitColumns,
      Aibe.DH.MICNRegexCheckedColumns,
      Aibe.DH.MICNRegexCheckedColumnExamples,
      Aibe.DH.MICNUserRelatedFilters,
      Aibe.DH.MICNDisableFilter,
      Aibe.DH.MICNForcedFilterColumns,
      Aibe.DH.MICNColumnExclusionList,
      Aibe.DH.MICNFilterExclusionList,
      Aibe.DH.MICNDetailsExclusionList,
      Aibe.DH.MICNCreateEditExclusionList,
      Aibe.DH.MICNCsvExclusionList,
      Aibe.DH.MICNAccessExclusionList,
      Aibe.DH.MICNColoringList,
      Aibe.DH.MICNFilterDropDownLists,
      Aibe.DH.MICNCreateEditDropDownLists,
      Aibe.DH.MICNPrefixesOfColumns,
      Aibe.DH.MICNPostfixesOfColumns,
      Aibe.DH.MICNListColumns,
      Aibe.DH.MICNTimeStampColumns,
      Aibe.DH.MICNHistoryTable,
      Aibe.DH.MICNHistoryTriggers,
      Aibe.DH.MICNAutoGeneratedColumns,
      Aibe.DH.MICNColumnSequence,
      Aibe.DH.MICNColumnAliases,
      Aibe.DH.MICNEditShowOnlyColumns,
      Aibe.DH.MICNScriptConstructorColumns,
      Aibe.DH.MICNScriptColumns,
      Aibe.DH.MICNCustomDateTimeFormatColumns,
      Aibe.DH.MICNEmailMakerTriggers,
      Aibe.DH.MICNEmailMakers,
      Aibe.DH.MICNNonPictureAttachmentColumns,
      Aibe.DH.MICNDownloadColumns,
      Aibe.DH.MICNPreActionTriggers,
      Aibe.DH.MICNPreActionProcedures,
      Aibe.DH.MICNPostActionTriggers,
      Aibe.DH.MICNPostActionProcedures,
      Aibe.DH.MICNTableType,
      Aibe.DH.MICNAggregationStatement,
      Aibe.DH.MICNForeignInfoColumns,
    };
    public readonly static List<SyntaxCombination> Combinations = new List<SyntaxCombination>() {
      new SyntaxCombination(string.Concat(Aibe.DH.MICNRegexCheckedColumns, "-", Aibe.DH.MICNRegexCheckedColumnExamples)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNHistoryTable, "-", Aibe.DH.MICNHistoryTriggers)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNScriptConstructorColumns, "-", Aibe.DH.MICNScriptColumns)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNEmailMakerTriggers, "-", Aibe.DH.MICNEmailMakers)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNPreActionTriggers, "-", Aibe.DH.MICNPreActionProcedures)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNPostActionTriggers, "-", Aibe.DH.MICNPostActionProcedures)),
      new SyntaxCombination(string.Concat(Aibe.DH.MICNTableType, "-", Aibe.DH.MICNAggregationStatement)),
    };
    public static List<string> ConfiguredTableNames { get; private set; } = new List<string>();
    public static Dictionary<string, List<string>> Options { get; private set; } = new Dictionary<string, List<string>>();
    public static List<string> MetaColumns { get; private set; } = new List<string>();
    public static List<BaseMetaItem> MetaList { get; private set; } = new List<BaseMetaItem>();
    public static List<string> Roles { get; private set; } = new List<string>();
    public static List<string> CompleteRoles { get; private set; } = new List<string>();
    public static List<MetaInfoTest> MetaInfoList { get; private set; } = new List<MetaInfoTest>();
    public static List<string> UserColumnNames { get; private set; } = new List<string>();
    public static Dictionary<string, List<string>> DataDBTableColumns { get; private set; } = new Dictionary<string, List<string>>();
    public static Dictionary<string, List<string>> UserDBTableColumns { get; private set; } = new Dictionary<string, List<string>>();
    public static Dictionary<string, List<string>> DataDBProcedureParameterNames { get; private set; } = new Dictionary<string, List<string>>();
    public static Dictionary<string, List<string>> UserDBProcedureParameterNames { get; private set; } = new Dictionary<string, List<string>>();
    public static Dictionary<string, string> DataDBProcedureSignatures { get; private set; } = new Dictionary<string, string>();
    public static Dictionary<string, string> UserDBProcedureSignatures { get; private set; } = new Dictionary<string, string>();
    public static List<string> DataTableColumnNames { get; private set; } = new List<string>();
    public static List<string> UserTableColumnNames { get; private set; } = new List<string>();
    public static List<string> DataProcedureParameterNames { get; private set; } = new List<string>();
    public static List<string> UserProcedureParameterNames { get; private set; } = new List<string>();
    public static List<string> TableSources { get; private set; } = new List<string>();
    public static List<string> TemplateNames { get; private set; } = new List<string>();
    public static bool UseDataDB { get; set; } = true; //this can be set outside
    static AibeSyntaxCheckerLogic() {
      Refresh();
    }

    public static void Refresh() {
      string roleTableName = ConfigurationManager.AppSettings["RoleTableName"];
      string userTableName = ConfigurationManager.AppSettings["UserTableName"];
      foreach (string column in MetaItemColumnNames) {
        if (Options.ContainsKey(column))
          continue;
        if (Combinations.Any(x => x.Columns.Any(y => y.EqualsIgnoreCase(column)))) {
          var parts = Combinations
            .Where(x => x.Columns.Any(y => y.EqualsIgnoreCase(column)));
          foreach (SyntaxCombination part in parts) {
            string join = String.Join("-", part.Columns);
            if (Options.ContainsKey(join))
              continue;
            Options.Add(join, new List<string>(part.Columns));
          }
        } else {
          Options.Add(column, new List<string>() { column });
        }
      }
      Roles = SQLServerHandler.GetSingleColumn(Aibe.DH.UserDBConnectionString, roleTableName, Aibe.DH.RoleNameColumnName)
        .Select(x => x.ToString()).ToList();
      CompleteRoles = Roles.Union(Aibe.DH.SpecialRoles).ToList();
      UserColumnNames = SQLServerHandler.GetColumns(Aibe.DH.UserDBConnectionString, userTableName)
        .Select(x => x.ColumnName).ToList();
      ConfiguredTableNames = MetaLogicTest.GetAllConfiguredTables();
      MetaColumns = MetaLogicTest.GetAllMetaColumns();
      DataTable table = SQLServerHandler.GetFullDataTable(Aibe.DH.DataDBConnectionString, Aibe.DH.MetaTableName);
      MetaList = BaseMetaItem.ExtractMetasFromDataTable(table).Select(x => x).ToList();
      DataDBTableColumns = SQLServerHandler.GetTablesViewsAndColumnNames(Aibe.DH.DataDBConnectionString);
      UserDBTableColumns = SQLServerHandler.GetTablesViewsAndColumnNames(Aibe.DH.UserDBConnectionString);
      DataTableColumnNames = DataDBTableColumns.Values.SelectMany(x => x).ToList();
      UserTableColumnNames = UserDBTableColumns.Values.SelectMany(x => x).ToList();
      TableSources = DataDBTableColumns.Keys.ToList();
      TemplateNames = SQLServerHandler.GetSingleColumn(Aibe.DH.DataDBConnectionString, Aibe.DH.EmailTemplateTableName, Aibe.DH.EmailMakerTemplateNameColumnName)
        .Select(x => x.ToString()).ToList();
      DataDBProcedureParameterNames = SQLServerHandler.GetProceduresAndParameterNames(Aibe.DH.DataDBConnectionString);
      UserDBProcedureParameterNames = SQLServerHandler.GetProceduresAndParameterNames(Aibe.DH.UserDBConnectionString);
      DataProcedureParameterNames = DataDBProcedureParameterNames.Values.SelectMany(x => x).ToList();
      UserProcedureParameterNames = UserDBProcedureParameterNames.Values.SelectMany(x => x).ToList();
      DataDBProcedureSignatures.Clear();
      UserDBProcedureSignatures.Clear();
      foreach (var item in DataDBProcedureParameterNames) {
        if (item.Value == null || item.Value.Count <= 0)
          continue;
        string signature = string.Concat(item.Key, "(", string.Join("=,", item.Value), "=)");
        DataDBProcedureSignatures.Add(item.Key, signature);
      }
      foreach (var item in UserDBProcedureParameterNames) {
        if (item.Value == null || item.Value.Count <= 0)
          continue;
        string signature = string.Concat(item.Key, "(", string.Join("=,", item.Value), "=)");
        UserDBProcedureSignatures.Add(item.Key, signature);
      }
      MetaInfoList = MetaList.Select(x => new MetaInfoTest(x)).ToList(); //must be put the last
    }

    public static void MinorUpdates() {
      ConfiguredTableNames = MetaLogicTest.GetAllConfiguredTables();
      DataTable table = SQLServerHandler.GetFullDataTable(Aibe.DH.DataDBConnectionString, Aibe.DH.MetaTableName);
      MetaList = BaseMetaItem.ExtractMetasFromDataTable(table).Select(x => x).ToList();
      MetaInfoList = MetaList.Select(x => new MetaInfoTest(x)).ToList(); //must be put the last
    }

    public static bool FindDataTable(string tableName) {
      if (string.IsNullOrWhiteSpace(tableName))
        return false;
      return DataDBTableColumns.ContainsKey(tableName);
    }

    public static bool FindUserTable(string tableName) {
      if (string.IsNullOrWhiteSpace(tableName))
        return false;
      return UserDBTableColumns.ContainsKey(tableName);
    }

    public static bool FindDataTableColumn(string tableName, string columnName) {
      if (string.IsNullOrWhiteSpace(tableName) || string.IsNullOrWhiteSpace(columnName))
        return false;
      if (!DataDBTableColumns.ContainsKey(tableName))
        return false;
      List<string> columns = DataDBTableColumns[tableName];
      return columns.Any(x => x.EqualsIgnoreCase(columnName));
    }

    public static bool FindUserTableColumn(string tableName, string columnName) {
      if (string.IsNullOrWhiteSpace(tableName) || string.IsNullOrWhiteSpace(columnName))
        return false;
      if (!UserDBTableColumns.ContainsKey(tableName))
        return false;
      List<string> columns = UserDBTableColumns[tableName];
      return columns.Any(x => x.EqualsIgnoreCase(columnName));
    }

    public static bool FindDataProcedure(string procedureName) {
      if (string.IsNullOrWhiteSpace(procedureName))
        return false;
      return DataDBProcedureParameterNames.ContainsKey(procedureName);
    }

    public static bool FindUserProcedure(string procedureName) {
      if (string.IsNullOrWhiteSpace(procedureName))
        return false;
      return UserDBProcedureParameterNames.ContainsKey(procedureName);
    }

    public static bool FindDataProcedureParameter(string procedureName, string parameterName) {
      if (string.IsNullOrWhiteSpace(procedureName) || string.IsNullOrWhiteSpace(parameterName))
        return false;
      if (!DataDBProcedureParameterNames.ContainsKey(procedureName))
        return false;
      List<string> parameters = DataDBProcedureParameterNames[procedureName];
      return parameters.Any(x => x.EqualsIgnoreCase(parameterName));
    }

    public static bool FindUserProcedureParameter(string procedureName, string parameterName) {
      if (string.IsNullOrWhiteSpace(procedureName) || string.IsNullOrWhiteSpace(parameterName))
        return false;
      if (!UserDBProcedureParameterNames.ContainsKey(procedureName))
        return false;
      List<string> parameters = UserDBProcedureParameterNames[procedureName];
      return parameters.Any(x => x.EqualsIgnoreCase(parameterName));
    }

    public static BaseErrorModel Check(string tableName, string column, string text) {
      if (string.IsNullOrWhiteSpace(tableName) || string.IsNullOrWhiteSpace(column))
        return new BaseErrorModel { Code = -1, Message = "Insufficient Info" };
      MetaInfoTest meta = MetaInfoList.FirstOrDefault(x => x.TableName.Equals(tableName));
      if (meta == null)
        return new BaseErrorModel { Code = -2, Message = "Meta Item Not Found" };
      MethodInfo method = typeof(MetaInfoTest).GetMethod("Evaluate" + column);
      if (method == null)
        return new BaseErrorModel { Code = -3, Message = "Evaluation Method On Column [" + column + "] Not Found" };
      if (string.IsNullOrWhiteSpace(text))
        return new BaseErrorModel { Code = -4, Message = "Text Not Available" };
      SyntaxCheckerResult result = (SyntaxCheckerResult)method.Invoke(meta, new object[] { text });
      return new BaseErrorModel { ReturnObject = result };
    }

    public static BaseErrorModel BasicCheck(string columnName, string text) {
      BaseMetaItem item = new BaseMetaItem();
      BaseMetaItemTest tester = new BaseMetaItemTest(item);
      MethodInfo method = tester.GetType().GetMethod("Test" + columnName);
      if (null == method) {
        SyntaxCheckerResult result = new SyntaxCheckerResult {
          Result = false,
          Message = "Checking Method Not Available",
        };
        return new BaseErrorModel { Code = -1, ReturnObject = result };
      }
      object objResult = method.Invoke(tester, new object[] { text });
      SyntaxCheckerResult finalResult = (SyntaxCheckerResult)objResult;
      return new BaseErrorModel { ReturnObject = finalResult };
    }

    public static BaseErrorModel UpdateMeta(string tableName, string columnName, string text) {
      MetaInfoTest meta = MetaInfoList.FirstOrDefault(x => x.TableName.EqualsIgnoreCase(tableName));
      if (meta == null)
        return new BaseErrorModel { Code = -1, Message = "Meta Item [" + tableName + "] Not Found" };
      MethodInfo method = typeof(MetaInfoTest).GetMethod("Update" + columnName);
      if (method == null)
        return new BaseErrorModel { Code = -2, Message = "Evaluation Method On Column [" + columnName + "] Not Found" };
      try {
        object val = method.Invoke(meta, new object[] { text });
        SqlParameter par0 = new SqlParameter("@par0", val == null ? DBNull.Value : val);
        SqlParameter par1 = new SqlParameter("@par1", tableName);
        BaseScriptModel script = new BaseScriptModel("UPDATE [" + Aibe.DH.MetaTableName + "] SET [" + columnName + "] = @par0 WHERE [" +
          Aibe.DH.MetaTableNameColumnName + "] = @par1",
          new List<SqlParameter> { par0, par1 });
        SQLServerHandler.ExecuteBaseScripts(Aibe.DH.DataDBConnectionString, new List<BaseScriptModel> { script });
        return new BaseErrorModel { Code = 0, Message = "Meta Item Update On Table [" + tableName + "] Column [" + columnName + "] Is Successful!" };
      } catch (Exception ex) {
        return new BaseErrorModel { Code = -3, Message = "Exception", Exception = ex.ToString(), StackTrace = ex.StackTrace.ToString() };
      }
    }

    public static List<AibeColoringSet> ShortenColorings(List<AibeColoringSet> colorings) {
      if (colorings == null || colorings.Count <= 0)
        return null;
      List<AibeColoringSet> shortenedColorings = new List<AibeColoringSet>();
      AibeColoringSet currentColoring = null;
      foreach (var coloring in colorings) {
        if (currentColoring == null) {
          currentColoring = coloring;
          continue;
        }
        bool result = currentColoring.TryAbsorb(coloring);
        if (result) //if it can absorb, simply continue to absorb
          continue;
        //fail to absorb, adds it
        shortenedColorings.Add(currentColoring);
        currentColoring = coloring; //replace the current coloring with the new coloring
      }
      if (currentColoring != null)
        shortenedColorings.Add(currentColoring);
      return shortenedColorings;
    }

    public List<AibeColoringSet> ShortenColoringsForDisplay(string text, List<AibeColoringSet> colorings) {
      if (string.IsNullOrWhiteSpace(text) || colorings == null || colorings.Count <= 0)
        return null;
      List<AibeColoringSet> shortenedColorings = new List<AibeColoringSet>();
      AibeColoringSet currentColoring = null;
      foreach (var coloring in colorings) {
        if (currentColoring == null) {
          currentColoring = coloring;
          continue;
        }
        bool result = currentColoring.TryAbsorb(coloring);
        if (result) //if it can absorb, simply continue to absorb
          continue;
        if (currentColoring.NextPosition == coloring.StartPosition) { //failure due to difference in color, adds it immediately
          shortenedColorings.Add(currentColoring);
          currentColoring = coloring; //replace the current coloring with the new coloring
          continue;
        } //otherwise, fail to absorb caused by different in distance
        //check the in between text, if there is any text which is not white character
        string inBetweenText = text.Substring(currentColoring.NextPosition, coloring.StartPosition - currentColoring.NextPosition);
        if (!string.IsNullOrWhiteSpace(inBetweenText)) { //there is something that is not of white character in between the text
          shortenedColorings.Add(currentColoring);
          currentColoring = coloring; //replace the current coloring with the new coloring
          continue;
        }
        //all in between text is white character
        currentColoring.Length += inBetweenText.Length; //extend the current length
        result = currentColoring.TryAbsorb(coloring); //try absorb the second time
        if (result) //we are happy if it can absord at this point
          continue;
        //if it still fails to absorb, then proccess it
        shortenedColorings.Add(currentColoring);
        currentColoring = coloring; //replace the current coloring with the new coloring
      }
      if (currentColoring != null)
        shortenedColorings.Add(currentColoring);
      return shortenedColorings;
    }

    public static List<AibeColoringSet> GetColoringSets(AibeDocument doc, string currentTable = null) {
      List<AibeColoringSet> colorSets = new List<AibeColoringSet>();
      foreach (var section in doc.Sections) {
        Color setColor = AibeDocument.SectionColors.ContainsKey(section.SectType) ? AibeDocument.SectionColors[section.SectType] : Color.Black;
        AibeColoringSet colorSet = new AibeColoringSet { StartPosition = section.StartIndex, Length = section.Length, UsedColor = setColor };
        colorSets.Add(colorSet);
      }
      return colorSets;
    }

    public static List<string> Colors = new List<string>(); //must be set outside!
    public readonly static List<string> Keywords = new List<string> { Aibe.DH.Skip, Aibe.DH.Self, Aibe.DH.Now,
      Aibe.DH.SQLScriptDirectivePrefix, Aibe.DH.DefaultHRTSColumnName, Aibe.DH.AutoGeneratedHRTSWord };
    public readonly static List<string> Tags = new List<string> { Aibe.DH.RegexCheckedColumnTag, Aibe.DH.RegexCheckedColumnExampleTag };
  }

  public class SyntaxCombination {
    public List<string> Columns { get; private set; } = new List<string>();
    public SyntaxCombination(string desc) {
      Columns = desc.GetTrimmedNonEmptyParts('-');
    }
  }

}
